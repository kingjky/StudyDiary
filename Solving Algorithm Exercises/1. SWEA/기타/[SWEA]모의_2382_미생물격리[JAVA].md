# [SWEA]모의 2382 미생물 격리[JAVA]

## 문제

정사각형 구역 안에 K개의 미생물 군집이 있다.

이 구역은 가로 N개, 세로 N개, 총 N * N 개의 동일한 크기의 정사각형 셀들로 이루어져 있다.

미생물들이 구역을 벗어나는걸 방지하기 위해, 가장 바깥쪽 가장자리 부분에 위치한 셀들에는 특수한 약품이 칠해져 있다.

[Fig. 1]은 9개의 군집이 한 변이 7개의 셀로 이루어진 구역에 배치되어 있는 예이다.

가장자리의 빨간 셀은 약품이 칠해져 있는 셀이다.

![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV599Ik6AH8DFAVl)
**[Fig. 1]**

 

  ① 최초 각 미생물 군집의 위치와 군집 내 미생물의 수, 이동 방향이 주어진다. 약품이 칠해진 부분에는 미생물이 배치되어 있지 않다. 이동방향은 상, 하, 좌, 우 네 방향 중 하나이다.

  ② 각 군집들은 1시간마다 이동방향에 있는 다음 셀로 이동한다.

  ③ 미생물 군집이 이동 후 약품이 칠해진 셀에 도착하면 군집 내 미생물의 절반이 죽고, 이동방향이 반대로 바뀐다. 
    미생물 수가 홀수인 경우 반으로 나누어 떨어지지 않으므로, 다음과 같이 정의한다.
    

**살아남은 미생물 수 = 원래 미생물 수를 2로 나눈 후 소수점 이하를 버림 한 값**


따라서 군집에 미생물이 한 마리 있는 경우 살아남은 미생물 수가 0이 되기 때문에, 군집이 사라지게 된다,

  ④ 이동 후 두 개 이상의 군집이 한 셀에 모이는 경우 군집들이 합쳐지게 된다. 
    합쳐 진 군집의 미생물 수는 군집들의 미생물 수의 합이며, 이동 방향은 군집들 중 미생물 수가 가장 많은 군집의 이동방향이 된다. 
    **합쳐지는 군집의 미생물 수가 같은 경우는 주어지지 않으므로 고려하지 않아도 된다.**


M 시간 동안 이 미생물 군집들을 격리하였다. M시간 후 남아 있는 미생물 수의 총합을 구하여라.

시간에 지남에 따라 군집이 변하는 예를 보자.

[Fig. 2]은 최초 군집의 배치를 그림으로 표현한 것이다. 이는 예제 입력 1번과 동일하다. (N = 7, K = 9)


![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV59-UbaAIIDFAVl)
**[Fig. 2]**


1시간 후 [Fig. 3]과 같이 군집들이 이동한다.

A 군집은 약품이 칠해진 구역(가장 자리의 빨간 셀)로 이동하게 되어, 미생물 중3마리만 남고 나머지는 죽는다. 이동 방향은 상에서 하로 바뀐다.

D, E, F 군집은 모두 세로 위치 3, 가로 위치 3에 위치한 셀로 모이게 되며, 합쳐진 군집의 미생물 수는 8 + 14 + 3 = 25가 된다.

E 군집의 미생물 수가 가장 많기 때문에, 합쳐 진 군집의 이동 방향은 E 군집의 이동 방향인 상이 된다.

G, H 군집도 세로 위치 2, 가로 위치 5에 위치한 셀로 모이게 되며, 미생물 수는 108이 되고 이동 방향은 상이 된다.

 

![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV59-iS6AIUDFAVl)
**[Fig. 3]**



시작으로부터 2시간이 지났을 때, [Fig. 4]와 같이 군집들이 이동한다.

A, B 그룹은 이동 중 섞이지 않고 각 그룹의 이동 방향으로 움직이는데, B 그룹은 약품이 칠해진 셀로 이동하므로 미생물 수가 7에서 3으로 반감하고, 이동 방향이 상에서 하로 바뀐다.

 

![img](https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&fileId=AV59-wPKAI4DFAVl)
**[Fig. 4]**



2시간이 지난 후, 남아 있는 미생물 수는 총 3 + 3 + 5 + 25 + 108 + 1 = 145이다.


**[제약사항]**

\1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는데, C/C++/Java 모두 5초

\2. 구역의 모양은 정사각형으로 주어지며, 한 변의 셀의 개수 N은 5이상 100이하의 정수이다. (5 ≤ N ≤ 100)

\3. 최초 배치되어 있는 미생물 군집의 개수 K는 5이상 1,000이하의 정수이다. (5 ≤ K ≤ 1,000)

\4. 격리 시간 M은 1이상 1,000이하의 정수이다. (1 ≤ M ≤ 1,000)

\5. 최초 약품이 칠해진 가장자리 부분 셀에는 미생물 군집이 배치되어 있지 않다.

\6. 최초에 둘 이상의 군집이 동일한 셀에 배치되는 경우는 없다.

\7. 각 군집 내 미생물 수는 1 이상 10,000 이하의 정수이다.

\8. 군집의 이동방향은 상하좌우 4방향 중 한 방향을 가진다. (상: 1, 하: 2, 좌: 3, 우: 4)

\9. 주어진 입력으로 진행하였을 때, 동일한 셀에 같은 미생물 수를 갖는 두 군집이 모이는 경우는 발생하지 않는다.

\10. 각 군집의 정보는 세로 위치, 가로 위치, 미생물 수, 이동 방향 순으로 주어진다. 각 위치는 0번부터 시작한다.


**[입력]**

첫 줄에는 총 테스트 케이스의 개수 T가 주어진다.

그 다음 줄부터 T개의 테스트 케이스가 차례대로 주어진다.

각 테스트 케이스의 첫째 줄에는 구역의 한 변에 있는 셀의 개수 N, 격리 시간 M, 미생물 군집의 개수 K가 순서대로 주어지며, 다음 K줄에 걸쳐서 미생물 군집 K개의 정보가 주어진다.

미생물 군집의 정보는 세로 위치, 가로 위치, 미생물 수, 이동 방향 순으로 4개의 정수가 주어진다.


**[출력]**

테스트 케이스의 개수 만큼 T개의 줄에 각 테스트 케이스에 대한 답을 출력한다.

각 줄은 “#x”로 시작하고, 공백을 하나 둔 후 정답을 출력한다. (x는 테스트 케이스의 번호이며, 1번부터 시작한다.)

출력해야 할 정답은 M시간 후 남아 있는 미생물 수의 총 합이다.

<details>
<summary>입/출력 데이터</summary>
<div markdown="1">

| 입력                                                         | 출력                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 10<br/>7 2 9<br/>1 1 7 1<br/>2 1 7 1<br/>5 1 5 4<br/>3 2 8 4<br/>4 3 14 1<br/>3 4 3 3<br/>1 5 8 2<br/>3 5 100 1<br/>5 5 1 1<br/>10 17 46<br/>7 5 724 2<br/>7 7 464 3<br/>2 2 827 2<br/>2 4 942 4<br/>4 5 604 4<br/>7 2 382 1<br/>6 5 895 3<br/>8 7 538 4<br/>6 1 299 4<br/>4 7 811 4<br/>3 6 664 2<br/>6 8 868 2<br/>7 6 859 2<br/>4 6 778 2<br/>5 4 842 3<br/>1 3 942 1<br/>1 1 805 3<br/>3 2 350 3<br/>2 5 623 2<br/>5 3 840 1<br/>7 1 308 4<br/>1 8 323 3<br/>2 3 82 3<br/>2 6 115 2<br/>8 3 930 1<br/>6 2 72 1<br/>2 1 290 3<br/>4 8 574 4<br/>8 5 150 3<br/>8 2 287 2<br/>2 8 909 2<br/>2 7 588 2<br/>7 3 30 3<br/>5 8 655 3<br/>3 8 537 1<br/>4 2 350 3<br/>5 6 199 1<br/>5 5 734 2<br/>3 3 788 1<br/>8 4 893 1<br/>1 4 421 4<br/>6 3 616 2<br/>1 2 556 4<br/>7 8 8 1<br/>5 2 702 2<br/>4 4 503 3<br/>10 5 28<br/>3 3 796 1<br/>7 2 798 2<br/>2 6 622 1<br/>3 5 179 3<br/>7 8 888 4<br/>5 8 634 3<br/>1 8 646 1<br/>3 7 433 4<br/>6 7 416 1<br/>2 7 651 3<br/>6 4 476 2<br/>5 6 712 4<br/>1 7 869 4<br/>6 1 789 2<br/>8 8 585 3<br/>7 6 426 1<br/>1 5 154 2<br/>1 2 692 1<br/>2 4 549 3<br/>2 1 60 2<br/>4 8 996 4<br/>8 2 437 2<br/>3 6 195 2<br/>1 3 734 4<br/>3 8 355 2<br/>1 1 945 1<br/>2 5 558 2<br/>7 7 144 2<br/>10 22 26<br/>2 2 450 4<br/>6 3 659 1<br/>5 8 24 2<br/>3 7 649 2<br/>3 2 22 3<br/>1 3 905 4<br/>7 8 625 3<br/>6 7 824 3<br/>7 3 159 1<br/>2 7 297 4<br/>7 2 270 2<br/>4 5 985 1<br/>7 1 627 2<br/>3 4 625 4<br/>8 5 972 4<br/>6 6 432 4<br/>6 8 142 1<br/>7 7 900 1<br/>4 1 974 2<br/>4 2 760 4<br/>1 4 550 2<br/>5 7 624 4<br/>4 6 694 1<br/>4 3 593 3<br/>3 1 152 4<br/>1 8 926 1<br/>10 7 15<br/>3 4 227 1<br/>4 7 109 1<br/>3 7 487 2<br/>2 3 627 2<br/>6 1 520 4<br/>7 3 596 4<br/>2 6 525 4<br/>1 5 116 3<br/>7 7 771 4<br/>4 4 520 2<br/>7 5 763 1<br/>5 4 829 3<br/>5 2 578 3<br/>6 8 200 2<br/>3 8 760 4<br/>10 24 12<br/>6 5 887 2<br/>2 3 428 1<br/>2 1 540 2<br/>8 1 356 4<br/>1 7 485 4<br/>5 1 357 3<br/>7 6 271 2<br/>6 2 22 1<br/>6 1 41 2<br/>8 2 565 2<br/>8 5 855 1<br/>6 3 734 1<br/>10 22 44<br/>2 2 963 1<br/>8 4 635 4<br/>4 1 938 4<br/>8 7 511 3<br/>6 8 825 4<br/>6 7 934 3<br/>3 7 701 4<br/>2 7 534 2<br/>5 2 705 1<br/>3 5 300 2<br/>6 2 855 4<br/>7 7 877 4<br/>1 7 443 1<br/>1 2 313 1<br/>3 3 932 2<br/>1 8 831 2<br/>1 1 90 2<br/>2 6 145 3<br/>2 3 740 4<br/>5 3 759 4<br/>1 6 181 1<br/>8 6 608 4<br/>5 6 556 2<br/>2 4 541 4<br/>2 1 174 2<br/>6 1 601 1<br/>7 5 84 4<br/>4 3 970 3<br/>8 8 503 1<br/>3 4 171 3<br/>5 7 913 4<br/>8 1 232 3<br/>7 6 539 4<br/>3 8 648 1<br/>8 2 944 2<br/>2 5 508 2<br/>5 1 87 1<br/>5 8 88 4<br/>2 8 681 2<br/>1 5 758 2<br/>3 1 690 3<br/>6 4 620 3<br/>5 4 783 1<br/>6 6 748 1<br/>10 9 38<br/>2 7 955 1<br/>7 7 25 4<br/>4 2 496 2<br/>1 4 342 1<br/>7 5 72 1<br/>3 7 429 2<br/>5 2 812 3<br/>8 6 36 2<br/>1 6 994 3<br/>1 5 838 1<br/>3 4 131 4<br/>7 2 11 2<br/>6 3 650 3<br/>7 3 353 2<br/>1 7 454 2<br/>8 3 256 4<br/>5 5 213 2<br/>6 5 80 1<br/>2 1 676 4<br/>4 6 561 3<br/>2 5 653 3<br/>3 5 923 3<br/>8 2 259 3<br/>4 4 781 2<br/>1 1 313 2<br/>3 6 938 3<br/>2 6 700 3<br/>4 1 215 2<br/>4 8 39 3<br/>5 1 954 3<br/>6 7 774 1<br/>5 8 541 4<br/>3 1 885 4<br/>7 8 867 2<br/>2 8 825 1<br/>5 6 598 3<br/>6 6 80 3<br/>8 1 405 2<br/>10 16 11<br/>5 7 87 3<br/>2 5 686 1<br/>6 7 64 2<br/>6 8 873 3<br/>5 6 762 2<br/>8 4 268 3<br/>7 3 307 4<br/>1 7 809 3<br/>5 5 293 3<br/>5 1 345 3<br/>4 1 114 4<br/>10 8 19<br/>3 1 52 4<br/>6 8 423 3<br/>7 3 498 4<br/>7 5 633 3<br/>7 7 392 3<br/>6 6 458 4<br/>3 8 830 3<br/>5 1 799 3<br/>1 1 540 3<br/>4 8 567 3<br/>1 6 897 3<br/>5 4 230 1<br/>2 6 229 3<br/>1 5 147 1<br/>4 1 754 2<br/>3 3 569 1<br/>7 8 515 4<br/>2 4 528 4<br/>2 1 962 2<br/>10 24 36<br/>6 6 923 3<br/>7 6 910 2<br/>2 1 278 2<br/>2 5 164 3<br/>8 6 505 4<br/>2 8 970 1<br/>1 1 85 2<br/>1 6 194 1<br/>5 3 572 1<br/>7 4 611 4<br/>6 2 565 4<br/>1 3 609 4<br/>1 7 74 2<br/>6 5 573 4<br/>5 1 31 3<br/>7 7 779 3<br/>7 1 391 3<br/>8 5 364 3<br/>7 8 474 1<br/>5 6 547 3<br/>2 6 195 2<br/>3 7 754 4<br/>1 8 912 1<br/>3 8 415 1<br/>5 8 434 4<br/>5 7 958 4<br/>2 7 700 3<br/>4 5 974 1<br/>4 7 376 4<br/>3 1 111 1<br/>3 6 486 1<br/>8 4 545 1<br/>5 2 237 3<br/>4 2 850 2<br/>2 4 793 2<br/>6 3 877 2<br/>20 5 30<br/>1 14 823 3<br/>6 14 595 4<br/>10 6 1310 3<br/>13 7 1487 3<br/>15 3 258 4<br/>14 15 1286 4<br/>7 7 1128 1<br/>3 10 1503 3<br/>18 8 1881 3<br/>6 17 598 3<br/>1 16 756 4<br/>18 11 1435 2<br/>12 18 1386 3<br/>4 9 48 3<br/>1 9 1840 2<br/>17 8 1599 3<br/>12 5 1328 3<br/>13 12 1794 1<br/>3 1 1432 4<br/>14 9 1497 1<br/>6 2 841 4<br/>10 9 648 1<br/>2 16 633 3<br/>12 3 1990 3<br/>12 6 578 1<br/>8 1 1487 1<br/>6 13 193 1<br/>11 10 1834 1<br/>5 16 529 2<br/>5 14 1392 4 | #1 145<br/>#2 5507<br/>#3 9709<br/>#4 2669<br/>#5 3684<br/>#6 774<br/>#7 4797<br/>#8 8786<br/>#9 1374<br/>#10 5040 |

</div>
</details>


## 풀이 방법

- 최초 풀이
  - 시뮬레이션 형태
  - 각 군집의 이동이 동시에 이뤄져야 하므로
    - 각 군집의 정보를 Queue에 담은 뒤 순차적으로 꺼내 한번씩 이동시킨 뒤
    - 군집 내 미생물 수
    - 군집의 이동 방향 처리
- 더 나은 풀이
  - 문제 분석
    - 미생물 군집들이 자기 방향과 마릿 수를 가지고 한시간마다 한칸씩 이동
    - M 시간이 지난 후 남은 미생물의 총 마릿 수를 출력
  - 주의사항
    - 1시간이 지나면 모든 군집은 무조건 이동함
      1. 약품이 처리된 셀로 간 경우
      2. 그렇지 않은 내부 셀 내에서 이동한 경우
         - 내부 셀에서 이동했는데 두개 이상의 군집이 모이는 경우

## 실행 코드

- 더 나은 풀이

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Solution_모의_2382_미생물격리 {
    static int di[] = { 0, -1, 1, 0, 0 }; // 0:up, 1:down, 2:left, 3:right
    static int dj[] = { 0, 0, 0, -1, 1 };

    static int N;
    static int M;
    static int K;

    static List<Virus> list;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int TC = Integer.parseInt(sc.nextLine());

        for (int tc = 1; tc <= TC; tc++) {
            N = sc.nextInt(); // map size
            M = sc.nextInt(); // time
            K = sc.nextInt(); // virus cnt

            list = new ArrayList();
            for (int k = 0; k < K; k++) {
                int i = sc.nextInt();
                int j = sc.nextInt();
                int cnt = sc.nextInt();
                int dir = sc.nextInt();
                list.add(new Virus(i * N + j, i, j, cnt, dir)); // 이차 배열의 한칸을 하나의 번호로 만드는 작업
            }

            for (int time = 0; time < M; time++) {
                for (int idx = 0; idx < list.size(); idx++) { // 모든 군집 한칸씩 이동해라.
                    Virus virus = list.get(idx);
                    virus.i = virus.i + di[virus.dir];
                    virus.j = virus.j + dj[virus.dir];
                    virus.num = (virus.i * N) + virus.j; // 이동한 칸번호 새로 계산해서 갱신

                    if (virus.i == 0 || virus.j == 0 || virus.i == N - 1 || virus.j == N - 1) {// 약품
                        virus.cnt /= 2;
                        virus.dir = changeDir(virus.dir);
                        if (virus.cnt == 0) {
                            list.remove(idx);
                            idx--;
                        }
                    }
                }

                // 위치 인덱스로 정렬시키고
                Collections.sort(list);
                for (int idx = 0; idx < list.size() - 1; idx++) {
                    Virus now = list.get(idx);
                    Virus next = list.get(idx + 1);
                    if (now.num == next.num) { // 위치가 같은 경우 미생물 수로 내림차순임. 다음놈을 걍 지우면 됨.
                        now.cnt += next.cnt; // next가 미생물 더 적으니까 흡수시키자.
                        list.remove(idx + 1);
                        idx--;
                    }
                }

            }

            int total = 0;
            for (int p = 0; p < list.size(); p++) {
                total += list.get(p).cnt;
            }
            System.out.println("#" + tc + " " + total);

        }
    }

    static int changeDir(int dir) {
        switch (dir) {
        case 1:
            return 2;
        case 2:
            return 1;
        case 3:
            return 4;
        case 4:
            return 3;
        }
        return -1;
    }

    static class Virus implements Comparable {
        int num; // 어느 칸에 있는지를 하나의 칸 번호로 만들어서 유지하도록.
        int i, j;
        int cnt;
        int dir;

        Virus(int num, int i, int j, int cnt, int dir) {
            this.num = num;
            this.i = i;
            this.j = j;
            this.cnt = cnt;
            this.dir = dir;
        }

		@Override
		public int compareTo(Object o) {
			if (this.num == ((Virus)o).num) { // 같은 칸에 있는 군집은 마릿수로 내림차순
                return ((Virus)o).cnt - this.cnt;
            }
            return this.num - ((Virus)o).num;
		}

    }
}
```

| 메모리     | 실행시간 |
| ---------- | -------- |
| 105,124 kb | 434 ms   |