# [SWEA]D5_1907_모래성쌓기[JAVA]

## 문제

산골에 있는 삼성초등학교에 다니는 학생들에게 바다란 미지의 영역이다. 여름방학을 맞아 학생들은 바다로 놀러 왔다.

드넓은 백사장과 저 멀리 뻗은 수평선이 학생들을 맞이해 주었다.

학생들은 낮에는 바다에서 신나게 놀았고, 이제 밤이 되어 백사장에서 모래성을 짓고 놀기로 하였다.

계획적인 것을 좋아하는 삼성초등학교 학생들은 2차원 격자단위로 모래성을 만들었는데, 각 격자에 들어있는 모래마다 튼튼함의 정도가 다르다.

튼튼함이란 모래성에 파도가 칠 때 격자에 들어있는 모래가 무너져서 씻겨 나갈지 아닐지를 의미하는데 1에서 9사이의 숫자로 표현되며,

파도가 칠 때 현재 격자의 주변 8방향(상하좌우 대각선)에 모래가 있지 않은 칸의 개수가 현재 칸의 튼튼함보다 많거나 같을 경우 파도에 의해 무너짐을 의미한다.

모래성에 파도가 치면 칠수록 모래성을 깎여 나가고 최종적으로는 하나의 형태로 수렴한다.

과연 몇 번의 파도가 쳐야 모래성의 형태가 더 이상 변하지 않게 될까?


**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스마다 모래성의 격자의 크기 H, W(1 ≤ H, W ≤ 1,000)이 공백으로 구분되어 주어진다.

다음 H줄에는 길이가 W인 문자열이 주어진다.

문자열은 ‘.’또는 ‘1’~‘9’로 구성되어 있으며 숫자는 각 칸에 들어 있는 모래의 튼튼함을 의미하고 ‘.’는 모래가 없는 칸임을 의미한다.

격자의 최 외곽부는 모두 ‘.’이다.


**[출력]**

각 테스트 케이스마다 몇 번의 파도가 쳐야 모래성의 형태가 더 이상 변하지 않게 되는지를 출력한다.


**[예제 풀이]**

첫 번째 테스트 케이스는 다음과 같이 모습이 변화한다.

```
......
.939..
.3428.
.9393.
......

......
.9.9..
..428.
.9.9..
......

......
.9.9..
..4.8.
.9.9..
......

......
.9.9..
....8.
.9.9..
......
```



 


| 입력                                                         | 출력           |
| ------------------------------------------------------------ | -------------- |
| 2<br/>5 6<br/>......<br/>.939..<br/>.3428.<br/>.9393.<br/>......<br/>10 10<br/>..........<br/>.99999999.<br/>.9.323239.<br/>.91444449.<br/>.91444449.<br/>.91444449.<br/>.91444449.<br/>.91232329.<br/>.99999999.<br/>.......... | #1 3<br/>#2 35 |

## 풀이 방법

- 최초 1회만 파도로 인해 깎이는 기존 모래성을 검사하고, 이를 que에 저장한 뒤 하나씩 꺼내면서 사라진 모래성들에 대해 8방의 모래성들의 내구도를 감소시키면 자연스럽게 0이 되는 것들은 다음 파도에 깎여나가는 것이라는 것을 알 수 있다.

- 가장 천천히 붕괴되는 시나리오

  ```
  .....
  .645.
  .546.
  .877.
  .....
  
  .....
  .675.
  .584.
  .656.
  .....
  ```

  

## 실행 코드

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Solution_D5_1907_모래성쌓기 {
	private static class Node{
		int r, c;
		private Node(int r, int c) {
			super();
			this.r = r;
			this.c = c;
		}
	}
	static int[] dr = {-1, -1, -1, 0, 1, 1, 1, 0};
	static int[] dc = {-1, 0, 1, 1, 1, 0, -1, -1};
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int tc = 1; tc <= T; tc++) {
			int H = sc.nextInt(); // 1<= H, W, <= 1000
			int W = sc.nextInt();
			int[][] map = new int[H][W];
			for (int r = 0; r < H; r++) {
				String str = sc.next();
				for (int c = 0; c < W; c++) {
					if(str.charAt(c) != '.')
						map[r][c] = str.charAt(c)-'0';
				}
			}
			Queue<Node> que = new LinkedList<>();
			for (int r = 0; r < H; r++) {
				for (int c = 0; c < W; c++) {
					//바다라면
					if(map[r][c] == 0) {
						//8방에 대해서 모래가 존재한다면 견고함을 1 감소시키기
						for (int d = 0; d < 8; d++) {
							int nr = r + dr[d];
							int nc = c + dc[d];
							if(nr<0 || nr>=H || nc<0 || nc>=W) continue;
							if(map[nr][nc] > 0) {
								map[nr][nc]--;
								if(map[nr][nc] == 0) {
									// 원래는 모래였으나 깎여서 바다가 된 친구는 -1 로 표시하자.
									map[nr][nc] = -1;
									// 다음 회차에서 주변 모래의 견고함을 줄이기 위해 큐에 저장.
									que.add(new Node(nr,nc));
								}
							}
						}
					}
				}
			}
			int ans = 0;
			while(!que.isEmpty()) {
				int size = que.size();
				for (int i = 0; i < size; i++) {
					Node node = que.poll();
					for (int d = 0; d < 8; d++) {
						int nr = node.r + dr[d];
						int nc = node.c + dc[d];
						if(nr<0 || nr>=H || nc<0 || nc>=W) continue;
						if(map[nr][nc] > 0) {
							map[nr][nc]--;
							if(map[nr][nc] == 0) {
								// 원래는 모래였으나 깎여서 바다가 된 친구는 -1 로 표시하자.
								map[nr][nc] = -1;
								// 다음 회차에서 주변 모래의 견고함을 줄이기 위해 큐에 저장.
								que.add(new Node(nr,nc));
							}
						}
					}
				}
				ans++;
			}
			System.out.printf("#%d %d\n",tc,ans);
		}
	}

}

```

